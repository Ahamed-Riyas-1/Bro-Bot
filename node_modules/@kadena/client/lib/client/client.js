"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = void 0;
const chainweb_node_client_1 = require("@kadena/chainweb-node-client");
const runPact_1 = require("./api/runPact");
const spv_1 = require("./api/spv");
const status_1 = require("./api/status");
const utils_1 = require("./utils/utils");
/**
 * Creates Chainweb client
 * @public
 */
const createClient = (host = utils_1.kadenaHostGenerator, defaults = { confirmationDepth: 0 }) => {
    const confirmationDepth = defaults.confirmationDepth;
    const getHost = typeof host === 'string' ? () => host : host;
    const client = {
        local(body, options) {
            const cmd = JSON.parse(body.cmd);
            const hostUrl = getHost({
                chainId: cmd.meta.chainId,
                networkId: cmd.networkId,
            });
            return (0, chainweb_node_client_1.local)(body, hostUrl, options);
        },
        submit: (async (body) => {
            const isList = Array.isArray(body);
            const commands = isList ? body : [body];
            const [first] = commands;
            if (first === undefined) {
                throw new Error('EMPTY_COMMAND_LIST');
            }
            const cmd = JSON.parse(first.cmd);
            const hostUrl = getHost({
                chainId: cmd.meta.chainId,
                networkId: cmd.networkId,
            });
            const { requestKeys } = await (0, chainweb_node_client_1.send)({ cmds: commands }, hostUrl);
            const transactionDescriptors = requestKeys.map((key) => ({
                requestKey: key,
                chainId: cmd.meta.chainId,
                networkId: cmd.networkId,
            }));
            return isList ? transactionDescriptors : transactionDescriptors[0];
        }),
        pollStatus(transactionDescriptors, options) {
            const requestsList = Array.isArray(transactionDescriptors)
                ? transactionDescriptors
                : [transactionDescriptors];
            const results = (0, utils_1.groupByHost)(requestsList.map(({ requestKey, chainId, networkId }) => ({
                requestKey,
                hostUrl: getHost({ chainId, networkId }),
            }))).map(([hostUrl, requestKeys]) => (0, status_1.pollStatus)(hostUrl, requestKeys, { confirmationDepth, ...options }));
            // merge all of the result in one object
            const mergedPollRequestPromises = (0, utils_1.mergeAllPollRequestPromises)(results);
            return mergedPollRequestPromises;
        },
        async getStatus(transactionDescriptors) {
            const requestsList = Array.isArray(transactionDescriptors)
                ? transactionDescriptors
                : [transactionDescriptors];
            const results = await Promise.all((0, utils_1.groupByHost)(requestsList.map(({ requestKey, chainId, networkId }) => ({
                requestKey,
                hostUrl: getHost({ chainId, networkId }),
            }))).map(([hostUrl, requestKeys]) => (0, chainweb_node_client_1.poll)({ requestKeys }, hostUrl)));
            // merge all of the result in one object
            const mergedResults = (0, utils_1.mergeAll)(results);
            return mergedResults;
        },
        async listen({ requestKey, chainId, networkId }) {
            const hostUrl = getHost({ chainId, networkId });
            const result = await (0, chainweb_node_client_1.listen)({ listen: requestKey }, hostUrl);
            return result;
        },
        pollCreateSpv({ requestKey, chainId, networkId }, targetChainId, options) {
            const hostUrl = getHost({ chainId, networkId });
            return (0, spv_1.pollSpv)(hostUrl, requestKey, targetChainId, options);
        },
        async createSpv({ requestKey, chainId, networkId }, targetChainId) {
            const hostUrl = getHost({ chainId, networkId });
            return (0, spv_1.getSpv)(hostUrl, requestKey, targetChainId);
        },
    };
    return {
        ...client,
        submitOne: client.submit,
        preflight(body) {
            return client.local(body, {
                preflight: true,
                signatureVerification: true,
            });
        },
        signatureVerification(body) {
            return client.local(body, {
                preflight: false,
                signatureVerification: true,
            });
        },
        dirtyRead(body) {
            return client.local(body, {
                preflight: false,
                signatureVerification: false,
            });
        },
        runPact: (code, data, options) => {
            const hostUrl = getHost(options);
            if (hostUrl === '')
                throw new Error('NO_HOST_URL');
            return (0, runPact_1.runPact)(hostUrl, code, data);
        },
        send: client.submit,
        getPoll: client.getStatus,
        pollOne: (transactionDescriptor, options) => {
            return client
                .pollStatus(transactionDescriptor, options)
                .then((res) => res[transactionDescriptor.requestKey]);
        },
    };
};
exports.createClient = createClient;
//# sourceMappingURL=client.js.map